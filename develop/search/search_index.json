{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GTR","text":"<p>A unified library for object tracking</p>"},{"location":"trackers/core/sort_tracker/","title":"SORT: Simple Online and Realtime Tracking","text":""},{"location":"trackers/core/sort_tracker/#sorttracker","title":"<code>SORTTracker</code>","text":"<p>               Bases: <code>BaseTracker</code></p> <p><code>SORTTracker</code> is an implementation of the SORT (Simple Online and Realtime Tracking) algorithm for object tracking in videos.</p> Example <pre><code>import numpy as np\nimport supervision as sv\nfrom rfdetr import RFDETRBase\nfrom rfdetr.util.coco_classes import COCO_CLASSES\nfrom trackers import SORTTracker\n\n\nmodel = RFDETRBase(device=\"mps\")\ntracker = SORTTracker()\nbox_annotator = sv.BoxAnnotator()\nlabel_annotator = sv.LabelAnnotator()\n\n\ndef callback(frame: np.ndarray, _: int):\n    detections = model.predict(frame, threshold=0.5)\n    detections = tracker.update(detections)\n\n    labels = [\n        f\"#{tracker_id} {COCO_CLASSES[class_id]} {confidence:.2f}\"\n        for tracker_id, class_id, confidence in zip(\n            detections.tracker_id, detections.class_id, detections.confidence\n        )\n    ]\n\n    annotated_image = frame.copy()\n    annotated_image = box_annotator.annotate(annotated_image, detections)\n    annotated_image = label_annotator.annotate(\n        annotated_image, detections, labels\n    )\n\n    return annotated_image\n\n\nsv.process_video(\n    source_path=\"data/traffic_video.mp4\",\n    target_path=\"data/out.mp4\",\n    callback=callback,\n)\n</code></pre> <p>Attributes:</p> Name Type Description <code>trackers</code> <code>list[SORTKalmanBoxTracker]</code> <p>List of SORTKalmanBoxTracker objects.</p> <p>Parameters:</p> Name Type Description Default <code>lost_track_buffer</code> <code>int</code> <p>Number of frames to buffer when a track is lost. Increasing lost_track_buffer enhances occlusion handling, significantly improving tracking through occlusions, but may increase the possibility of ID switching for objects with similar appearance.</p> <code>30</code> <code>frame_rate</code> <code>float</code> <p>Frame rate of the video (frames per second). Used to calculate the maximum time a track can be lost.</p> <code>30.0</code> <code>track_activation_threshold</code> <code>float</code> <p>Detection confidence threshold for track activation. Only detections with confidence above this threshold will create new tracks. Increasing this threshold reduces false positives but may miss real objects with low confidence.</p> <code>0.25</code> <code>minimum_consecutive_frames</code> <code>int</code> <p>Number of consecutive frames that an object must be tracked before it is considered a 'valid' track. Increasing <code>minimum_consecutive_frames</code> prevents the creation of accidental tracks from false detection or double detection, but risks missing shorter tracks. Before the tracker is considered valid, it will be assigned <code>-1</code> as its <code>tracker_id</code>.</p> <code>3</code> <code>minimum_iou_threshold</code> <code>float</code> <p>IOU threshold for associating detections to existing tracks.</p> <code>0.3</code> Source code in <code>trackers/core/sort/tracker.py</code> <pre><code>class SORTTracker(BaseTracker):\n    \"\"\"\n    `SORTTracker` is an implementation of the\n    [SORT (Simple Online and Realtime Tracking)](https://arxiv.org/pdf/1602.00763)\n    algorithm for object tracking in videos.\n\n    ??? example\n        ```python\n        import numpy as np\n        import supervision as sv\n        from rfdetr import RFDETRBase\n        from rfdetr.util.coco_classes import COCO_CLASSES\n        from trackers import SORTTracker\n\n\n        model = RFDETRBase(device=\"mps\")\n        tracker = SORTTracker()\n        box_annotator = sv.BoxAnnotator()\n        label_annotator = sv.LabelAnnotator()\n\n\n        def callback(frame: np.ndarray, _: int):\n            detections = model.predict(frame, threshold=0.5)\n            detections = tracker.update(detections)\n\n            labels = [\n                f\"#{tracker_id} {COCO_CLASSES[class_id]} {confidence:.2f}\"\n                for tracker_id, class_id, confidence in zip(\n                    detections.tracker_id, detections.class_id, detections.confidence\n                )\n            ]\n\n            annotated_image = frame.copy()\n            annotated_image = box_annotator.annotate(annotated_image, detections)\n            annotated_image = label_annotator.annotate(\n                annotated_image, detections, labels\n            )\n\n            return annotated_image\n\n\n        sv.process_video(\n            source_path=\"data/traffic_video.mp4\",\n            target_path=\"data/out.mp4\",\n            callback=callback,\n        )\n        ```\n\n    Attributes:\n        trackers (list[SORTKalmanBoxTracker]): List of SORTKalmanBoxTracker objects.\n\n    Args:\n        lost_track_buffer (int): Number of frames to buffer when a track is lost.\n            Increasing lost_track_buffer enhances occlusion handling, significantly\n            improving tracking through occlusions, but may increase the possibility\n            of ID switching for objects with similar appearance.\n        frame_rate (float): Frame rate of the video (frames per second).\n            Used to calculate the maximum time a track can be lost.\n        track_activation_threshold (float): Detection confidence threshold\n            for track activation. Only detections with confidence above this\n            threshold will create new tracks. Increasing this threshold\n            reduces false positives but may miss real objects with low confidence.\n        minimum_consecutive_frames (int): Number of consecutive frames that an object\n            must be tracked before it is considered a 'valid' track. Increasing\n            `minimum_consecutive_frames` prevents the creation of accidental tracks\n            from false detection or double detection, but risks missing shorter\n            tracks. Before the tracker is considered valid, it will be assigned\n            `-1` as its `tracker_id`.\n        minimum_iou_threshold (float): IOU threshold for associating detections to\n            existing tracks.\n    \"\"\"\n\n    def __init__(\n        self,\n        lost_track_buffer: int = 30,\n        frame_rate: float = 30.0,\n        track_activation_threshold: float = 0.25,\n        minimum_consecutive_frames: int = 3,\n        minimum_iou_threshold: float = 0.3,\n    ) -&gt; None:\n        # Calculate maximum frames without update based on lost_track_buffer and\n        # frame_rate. This scales the buffer based on the frame rate to ensure\n        # consistent time-based tracking across different frame rates.\n        self.maximum_frames_without_update = int(frame_rate / 30.0 * lost_track_buffer)\n        self.minimum_consecutive_frames = minimum_consecutive_frames\n        self.minimum_iou_threshold = minimum_iou_threshold\n        self.track_activation_threshold = track_activation_threshold\n\n        # Active trackers\n        self.trackers: list[SORTKalmanBoxTracker] = []\n\n    def _get_associated_indices(\n        self, iou_matrix: np.ndarray, detection_boxes: np.ndarray\n    ) -&gt; tuple[list[tuple[int, int]], set[int], set[int]]:\n        \"\"\"\n        Associate detections to trackers based on IOU\n\n        Args:\n            iou_matrix (np.ndarray): IOU cost matrix.\n            detection_boxes (np.ndarray): Detected bounding boxes in the\n                form [x1, y1, x2, y2].\n\n        Returns:\n            tuple[list[tuple[int, int]], set[int], set[int]]: Matched indices,\n                unmatched trackers, unmatched detections.\n        \"\"\"\n        matched_indices = []\n        unmatched_trackers = set(range(len(self.trackers)))\n        unmatched_detections = set(range(len(detection_boxes)))\n\n        if iou_matrix.size &gt; 0:\n            row_indices, col_indices = np.where(iou_matrix &gt; self.minimum_iou_threshold)\n            # Sort in descending order of IOU. Higher = better match.\n            sorted_pairs = sorted(\n                zip(row_indices, col_indices),\n                key=lambda x: iou_matrix[x[0], x[1]],\n                reverse=True,\n            )\n            # keep each unique row/col pair at most once\n            used_rows = set()\n            used_cols = set()\n            for row, col in sorted_pairs:\n                if (row not in used_rows) and (col not in used_cols):\n                    used_rows.add(row)\n                    used_cols.add(col)\n                    matched_indices.append((row, col))\n\n            unmatched_trackers = unmatched_trackers - used_rows\n            unmatched_detections = unmatched_detections - used_cols\n\n        return matched_indices, unmatched_trackers, unmatched_detections\n\n    def _spawn_new_trackers(\n        self,\n        detections: sv.Detections,\n        detection_boxes: np.ndarray,\n        unmatched_detections: set[int],\n    ) -&gt; None:\n        \"\"\"\n        Create new trackers only for unmatched detections with confidence\n        above threshold.\n\n        Args:\n            detections (sv.Detections): The latest set of object detections.\n            detection_boxes (np.ndarray): Detected bounding boxes in the\n                form [x1, y1, x2, y2].\n        \"\"\"\n        for detection_idx in unmatched_detections:\n            if (\n                detections.confidence is None\n                or detection_idx &gt;= len(detections.confidence)\n                or detections.confidence[detection_idx]\n                &gt;= self.track_activation_threshold\n            ):\n                new_tracker = SORTKalmanBoxTracker(detection_boxes[detection_idx])\n                self.trackers.append(new_tracker)\n        self.trackers = get_alive_trackers(\n            self.trackers,\n            self.minimum_consecutive_frames,\n            self.maximum_frames_without_update,\n        )\n\n    def update(self, detections: sv.Detections) -&gt; sv.Detections:\n        \"\"\"\n        Updates the state of tracked objects with the newly received detections\n        and returns the updated `sv.Detections` (including tracking IDs).\n\n        Args:\n            detections (sv.Detections): The latest set of object detections.\n\n        Returns:\n            sv.Detections: A copy of the detections with `tracker_id` set\n                for each detection that is tracked.\n        \"\"\"\n        if len(self.trackers) == 0 and len(detections) == 0:\n            return detections\n\n        # Convert detections to a (N x 4) array (x1, y1, x2, y2)\n        detection_boxes = (\n            detections.xyxy if len(detections) &gt; 0 else np.array([]).reshape(0, 4)\n        )\n\n        # Predict new locations for existing trackers\n        for tracker in self.trackers:\n            tracker.predict()\n\n        # Build IOU cost matrix between detections and predicted bounding boxes\n        iou_matrix = get_iou_matrix(self.trackers, detection_boxes)\n\n        # Associate detections to trackers based on IOU\n        matched_indices, _, unmatched_detections = self._get_associated_indices(\n            iou_matrix, detection_boxes\n        )\n\n        # Update matched trackers with assigned detections\n        for row, col in matched_indices:\n            self.trackers[row].update(detection_boxes[col])\n\n        self._spawn_new_trackers(detections, detection_boxes, unmatched_detections)\n\n        updated_detections = update_detections_with_track_ids(\n            self.trackers,\n            detections,\n            detection_boxes,\n            self.minimum_iou_threshold,\n            self.minimum_consecutive_frames,\n        )\n\n        return updated_detections\n\n    def reset(self) -&gt; None:\n        self.trackers = []\n        SORTKalmanBoxTracker.count_id = 0\n</code></pre>"},{"location":"trackers/core/sort_tracker/#trackers.core.sort.tracker.SORTTracker.update","title":"<code>update(detections)</code>","text":"<p>Updates the state of tracked objects with the newly received detections and returns the updated <code>sv.Detections</code> (including tracking IDs).</p> <p>Parameters:</p> Name Type Description Default <code>detections</code> <code>Detections</code> <p>The latest set of object detections.</p> required <p>Returns:</p> Type Description <code>Detections</code> <p>sv.Detections: A copy of the detections with <code>tracker_id</code> set for each detection that is tracked.</p> Source code in <code>trackers/core/sort/tracker.py</code> <pre><code>def update(self, detections: sv.Detections) -&gt; sv.Detections:\n    \"\"\"\n    Updates the state of tracked objects with the newly received detections\n    and returns the updated `sv.Detections` (including tracking IDs).\n\n    Args:\n        detections (sv.Detections): The latest set of object detections.\n\n    Returns:\n        sv.Detections: A copy of the detections with `tracker_id` set\n            for each detection that is tracked.\n    \"\"\"\n    if len(self.trackers) == 0 and len(detections) == 0:\n        return detections\n\n    # Convert detections to a (N x 4) array (x1, y1, x2, y2)\n    detection_boxes = (\n        detections.xyxy if len(detections) &gt; 0 else np.array([]).reshape(0, 4)\n    )\n\n    # Predict new locations for existing trackers\n    for tracker in self.trackers:\n        tracker.predict()\n\n    # Build IOU cost matrix between detections and predicted bounding boxes\n    iou_matrix = get_iou_matrix(self.trackers, detection_boxes)\n\n    # Associate detections to trackers based on IOU\n    matched_indices, _, unmatched_detections = self._get_associated_indices(\n        iou_matrix, detection_boxes\n    )\n\n    # Update matched trackers with assigned detections\n    for row, col in matched_indices:\n        self.trackers[row].update(detection_boxes[col])\n\n    self._spawn_new_trackers(detections, detection_boxes, unmatched_detections)\n\n    updated_detections = update_detections_with_track_ids(\n        self.trackers,\n        detections,\n        detection_boxes,\n        self.minimum_iou_threshold,\n        self.minimum_consecutive_frames,\n    )\n\n    return updated_detections\n</code></pre>"},{"location":"trackers/core/sort_tracker/#sortkalmanboxtracker","title":"<code>SORTKalmanBoxTracker</code>","text":"<p>The <code>SORTKalmanBoxTracker</code> class represents the internals of a single tracked object (bounding box), with a Kalman filter to predict and update its position.</p> <p>Attributes:</p> Name Type Description <code>tracker_id</code> <code>int</code> <p>Unique identifier for the tracker.</p> <code>number_of_successful_updates</code> <code>int</code> <p>Number of times the object has been updated successfully.</p> <code>time_since_update</code> <code>int</code> <p>Number of frames since the last update.</p> <code>state</code> <code>ndarray</code> <p>State vector of the bounding box.</p> <code>F</code> <code>ndarray</code> <p>State transition matrix.</p> <code>H</code> <code>ndarray</code> <p>Measurement matrix.</p> <code>Q</code> <code>ndarray</code> <p>Process noise covariance matrix.</p> <code>R</code> <code>ndarray</code> <p>Measurement noise covariance matrix.</p> <code>P</code> <code>ndarray</code> <p>Error covariance matrix.</p> <code>count_id</code> <code>int</code> <p>Class variable to assign unique IDs to each tracker.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>ndarray</code> <p>Initial bounding box in the form [x1, y1, x2, y2].</p> required Source code in <code>trackers/core/sort/kalman_box_tracker.py</code> <pre><code>class SORTKalmanBoxTracker:\n    \"\"\"\n    The `SORTKalmanBoxTracker` class represents the internals of a single\n    tracked object (bounding box), with a Kalman filter to predict and update\n    its position.\n\n    Attributes:\n        tracker_id (int): Unique identifier for the tracker.\n        number_of_successful_updates (int): Number of times the object has been\n            updated successfully.\n        time_since_update (int): Number of frames since the last update.\n        state (np.ndarray): State vector of the bounding box.\n        F (np.ndarray): State transition matrix.\n        H (np.ndarray): Measurement matrix.\n        Q (np.ndarray): Process noise covariance matrix.\n        R (np.ndarray): Measurement noise covariance matrix.\n        P (np.ndarray): Error covariance matrix.\n        count_id (int): Class variable to assign unique IDs to each tracker.\n\n    Args:\n        bbox (np.ndarray): Initial bounding box in the form [x1, y1, x2, y2].\n    \"\"\"\n\n    count_id = 0\n\n    @classmethod\n    def get_next_tracker_id(cls) -&gt; int:\n        next_id = cls.count_id\n        cls.count_id += 1\n        return next_id\n\n    def __init__(self, bbox: np.ndarray) -&gt; None:\n        # Initialize with a temporary ID of -1\n        # Will be assigned a real ID when the track is considered mature\n        self.tracker_id = -1\n\n        # Number of hits indicates how many times the object has been\n        # updated successfully\n        self.number_of_successful_updates = 1\n        # Number of frames since the last update\n        self.time_since_update = 0\n\n        # For simplicity, we keep a small state vector:\n        # (x, y, x2, y2, vx, vy, vx2, vy2).\n        # We'll store the bounding box in \"self.state\"\n        self.state = np.zeros((8, 1), dtype=np.float32)\n\n        # Initialize state directly from the first detection\n        self.state[0] = bbox[0]\n        self.state[1] = bbox[1]\n        self.state[2] = bbox[2]\n        self.state[3] = bbox[3]\n\n        # Basic constant velocity model\n        self._initialize_kalman_filter()\n\n    def _initialize_kalman_filter(self) -&gt; None:\n        \"\"\"\n        Sets up the matrices for the Kalman filter.\n        \"\"\"\n        # State transition matrix (F): 8x8\n        # We assume a constant velocity model. Positions are incremented by\n        # velocity each step.\n        self.F = np.eye(8, dtype=np.float32)\n        for i in range(4):\n            self.F[i, i + 4] = 1.0\n\n        # Measurement matrix (H): we directly measure x1, y1, x2, y2\n        self.H = np.eye(4, 8, dtype=np.float32)  # 4x8\n\n        # Process covariance matrix (Q)\n        self.Q = np.eye(8, dtype=np.float32) * 0.01\n\n        # Measurement covariance (R): noise in detection\n        self.R = np.eye(4, dtype=np.float32) * 0.1\n\n        # Error covariance matrix (P)\n        self.P = np.eye(8, dtype=np.float32)\n\n    def predict(self) -&gt; None:\n        \"\"\"\n        Predict the next state of the bounding box (applies the state transition).\n        \"\"\"\n        # Predict state\n        self.state = self.F @ self.state\n        # Predict error covariance\n        self.P = self.F @ self.P @ self.F.T + self.Q\n\n        # Increase time since update\n        self.time_since_update += 1\n\n    def update(self, bbox: np.ndarray) -&gt; None:\n        \"\"\"\n        Updates the state with a new detected bounding box.\n\n        Args:\n            bbox (np.ndarray): Detected bounding box in the form [x1, y1, x2, y2].\n        \"\"\"\n        self.time_since_update = 0\n        self.number_of_successful_updates += 1\n\n        # Kalman Gain\n        S = self.H @ self.P @ self.H.T + self.R\n        K = self.P @ self.H.T @ np.linalg.inv(S)\n\n        # Residual\n        measurement = bbox.reshape((4, 1))\n        y = measurement - self.H @ self.state\n\n        # Update state\n        self.state = self.state + K @ y\n\n        # Update covariance\n        identity_matrix = np.eye(8, dtype=np.float32)\n        self.P = (identity_matrix - K @ self.H) @ self.P\n\n    def get_state_bbox(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns the current bounding box estimate from the state vector.\n\n        Returns:\n            np.ndarray: The bounding box [x1, y1, x2, y2].\n        \"\"\"\n        return np.array(\n            [\n                self.state[0],  # x1\n                self.state[1],  # y1\n                self.state[2],  # x2\n                self.state[3],  # y2\n            ],\n            dtype=float,\n        ).reshape(-1)\n</code></pre>"},{"location":"trackers/core/sort_tracker/#trackers.core.sort.kalman_box_tracker.SORTKalmanBoxTracker.get_state_bbox","title":"<code>get_state_bbox()</code>","text":"<p>Returns the current bounding box estimate from the state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The bounding box [x1, y1, x2, y2].</p> Source code in <code>trackers/core/sort/kalman_box_tracker.py</code> <pre><code>def get_state_bbox(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns the current bounding box estimate from the state vector.\n\n    Returns:\n        np.ndarray: The bounding box [x1, y1, x2, y2].\n    \"\"\"\n    return np.array(\n        [\n            self.state[0],  # x1\n            self.state[1],  # y1\n            self.state[2],  # x2\n            self.state[3],  # y2\n        ],\n        dtype=float,\n    ).reshape(-1)\n</code></pre>"},{"location":"trackers/core/sort_tracker/#trackers.core.sort.kalman_box_tracker.SORTKalmanBoxTracker.predict","title":"<code>predict()</code>","text":"<p>Predict the next state of the bounding box (applies the state transition).</p> Source code in <code>trackers/core/sort/kalman_box_tracker.py</code> <pre><code>def predict(self) -&gt; None:\n    \"\"\"\n    Predict the next state of the bounding box (applies the state transition).\n    \"\"\"\n    # Predict state\n    self.state = self.F @ self.state\n    # Predict error covariance\n    self.P = self.F @ self.P @ self.F.T + self.Q\n\n    # Increase time since update\n    self.time_since_update += 1\n</code></pre>"},{"location":"trackers/core/sort_tracker/#trackers.core.sort.kalman_box_tracker.SORTKalmanBoxTracker.update","title":"<code>update(bbox)</code>","text":"<p>Updates the state with a new detected bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>ndarray</code> <p>Detected bounding box in the form [x1, y1, x2, y2].</p> required Source code in <code>trackers/core/sort/kalman_box_tracker.py</code> <pre><code>def update(self, bbox: np.ndarray) -&gt; None:\n    \"\"\"\n    Updates the state with a new detected bounding box.\n\n    Args:\n        bbox (np.ndarray): Detected bounding box in the form [x1, y1, x2, y2].\n    \"\"\"\n    self.time_since_update = 0\n    self.number_of_successful_updates += 1\n\n    # Kalman Gain\n    S = self.H @ self.P @ self.H.T + self.R\n    K = self.P @ self.H.T @ np.linalg.inv(S)\n\n    # Residual\n    measurement = bbox.reshape((4, 1))\n    y = measurement - self.H @ self.state\n\n    # Update state\n    self.state = self.state + K @ y\n\n    # Update covariance\n    identity_matrix = np.eye(8, dtype=np.float32)\n    self.P = (identity_matrix - K @ self.H) @ self.P\n</code></pre>"},{"location":"trackers/utils/sort_utils/","title":"Utils for Kalman-filter based Trackers","text":""},{"location":"trackers/utils/sort_utils/#trackers.utils.sort_utils.get_alive_trackers","title":"<code>get_alive_trackers(trackers, minimum_consecutive_frames, maximum_frames_without_update)</code>","text":"<p>Remove dead or immature lost tracklets and get alive trackers that are within <code>maximum_frames_without_update</code> AND (it's mature OR it was just updated).</p> <p>Parameters:</p> Name Type Description Default <code>trackers</code> <code>Sequence[KalmanBoxTrackerType]</code> <p>List of KalmanBoxTracker objects.</p> required <code>minimum_consecutive_frames</code> <code>int</code> <p>Number of consecutive frames that an object must be tracked before it is considered a 'valid' track.</p> required <code>maximum_frames_without_update</code> <code>int</code> <p>Maximum number of frames without update before a track is considered dead.</p> required <p>Returns:</p> Type Description <code>List[KalmanBoxTrackerType]</code> <p>List[KalmanBoxTrackerType]: List of alive trackers.</p> Source code in <code>trackers/utils/sort_utils.py</code> <pre><code>def get_alive_trackers(\n    trackers: Sequence[KalmanBoxTrackerType],\n    minimum_consecutive_frames: int,\n    maximum_frames_without_update: int,\n) -&gt; List[KalmanBoxTrackerType]:\n    \"\"\"\n    Remove dead or immature lost tracklets and get alive trackers\n    that are within `maximum_frames_without_update` AND (it's mature OR\n    it was just updated).\n\n    Args:\n        trackers (Sequence[KalmanBoxTrackerType]): List of KalmanBoxTracker objects.\n        minimum_consecutive_frames (int): Number of consecutive frames that an object\n            must be tracked before it is considered a 'valid' track.\n        maximum_frames_without_update (int): Maximum number of frames without update\n            before a track is considered dead.\n\n    Returns:\n        List[KalmanBoxTrackerType]: List of alive trackers.\n    \"\"\"\n    alive_trackers = []\n    for tracker in trackers:\n        is_mature = tracker.number_of_successful_updates &gt;= minimum_consecutive_frames\n        is_active = tracker.time_since_update == 0\n        if tracker.time_since_update &lt; maximum_frames_without_update and (\n            is_mature or is_active\n        ):\n            alive_trackers.append(tracker)\n    return alive_trackers\n</code></pre>"},{"location":"trackers/utils/sort_utils/#trackers.utils.sort_utils.get_iou_matrix","title":"<code>get_iou_matrix(trackers, detection_boxes)</code>","text":"<p>Build IOU cost matrix between detections and predicted bounding boxes</p> <p>Parameters:</p> Name Type Description Default <code>detection_boxes</code> <code>ndarray</code> <p>Detected bounding boxes in the form [x1, y1, x2, y2].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: IOU cost matrix.</p> Source code in <code>trackers/utils/sort_utils.py</code> <pre><code>def get_iou_matrix(\n    trackers: Sequence[KalmanBoxTrackerType], detection_boxes: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"\n    Build IOU cost matrix between detections and predicted bounding boxes\n\n    Args:\n        detection_boxes (np.ndarray): Detected bounding boxes in the\n            form [x1, y1, x2, y2].\n\n    Returns:\n        np.ndarray: IOU cost matrix.\n    \"\"\"\n    predicted_boxes = np.array([t.get_state_bbox() for t in trackers])\n    if len(predicted_boxes) == 0 and len(trackers) &gt; 0:\n        # Handle case where get_state_bbox might return empty array\n        predicted_boxes = np.zeros((len(trackers), 4), dtype=np.float32)\n\n    if len(trackers) &gt; 0 and len(detection_boxes) &gt; 0:\n        iou_matrix = box_iou_batch(predicted_boxes, detection_boxes)\n    else:\n        iou_matrix = np.zeros((len(trackers), len(detection_boxes)), dtype=np.float32)\n\n    return iou_matrix\n</code></pre>"},{"location":"trackers/utils/sort_utils/#trackers.utils.sort_utils.update_detections_with_track_ids","title":"<code>update_detections_with_track_ids(trackers, detections, detection_boxes, minimum_iou_threshold, minimum_consecutive_frames)</code>","text":"<p>The function prepares the updated Detections with track IDs. If a tracker is \"mature\" (&gt;= <code>minimum_consecutive_frames</code>) or recently updated, it is assigned an ID to the detection that just updated it.</p> <p>Parameters:</p> Name Type Description Default <code>trackers</code> <code>Sequence[SORTKalmanBoxTracker]</code> <p>List of SORTKalmanBoxTracker objects.</p> required <code>detections</code> <code>Detections</code> <p>The latest set of object detections.</p> required <code>detection_boxes</code> <code>ndarray</code> <p>Detected bounding boxes in the form [x1, y1, x2, y2].</p> required <code>minimum_iou_threshold</code> <code>float</code> <p>IOU threshold for associating detections to existing tracks.</p> required <code>minimum_consecutive_frames</code> <code>int</code> <p>Number of consecutive frames that an object must be tracked before it is considered a 'valid' track.</p> required <p>Returns:</p> Type Description <code>Detections</code> <p>sv.Detections: A copy of the detections with <code>tracker_id</code> set for each detection that is tracked.</p> Source code in <code>trackers/utils/sort_utils.py</code> <pre><code>def update_detections_with_track_ids(\n    trackers: Sequence[KalmanBoxTrackerType],\n    detections: sv.Detections,\n    detection_boxes: np.ndarray,\n    minimum_iou_threshold: float,\n    minimum_consecutive_frames: int,\n) -&gt; sv.Detections:\n    \"\"\"\n    The function prepares the updated Detections with track IDs.\n    If a tracker is \"mature\" (&gt;= `minimum_consecutive_frames`) or recently updated,\n    it is assigned an ID to the detection that just updated it.\n\n    Args:\n        trackers (Sequence[SORTKalmanBoxTracker]): List of SORTKalmanBoxTracker objects.\n        detections (sv.Detections): The latest set of object detections.\n        detection_boxes (np.ndarray): Detected bounding boxes in the\n            form [x1, y1, x2, y2].\n        minimum_iou_threshold (float): IOU threshold for associating detections to\n            existing tracks.\n        minimum_consecutive_frames (int): Number of consecutive frames that an object\n            must be tracked before it is considered a 'valid' track.\n\n    Returns:\n        sv.Detections: A copy of the detections with `tracker_id` set\n            for each detection that is tracked.\n    \"\"\"\n    # Re-run association in the same way (could also store direct mapping)\n    final_tracker_ids = [-1] * len(detection_boxes)\n\n    # Recalculate predicted_boxes based on current trackers after some may have\n    # been removed\n    predicted_boxes = np.array([t.get_state_bbox() for t in trackers])\n    iou_matrix_final = np.zeros((len(trackers), len(detection_boxes)), dtype=np.float32)\n\n    # Ensure predicted_boxes is properly shaped before the second iou calculation\n    if len(predicted_boxes) == 0 and len(trackers) &gt; 0:\n        predicted_boxes = np.zeros((len(trackers), 4), dtype=np.float32)\n\n    if len(trackers) &gt; 0 and len(detection_boxes) &gt; 0:\n        iou_matrix_final = box_iou_batch(predicted_boxes, detection_boxes)\n\n    row_indices, col_indices = np.where(iou_matrix_final &gt; minimum_iou_threshold)\n    sorted_pairs = sorted(\n        zip(row_indices, col_indices),\n        key=lambda x: iou_matrix_final[x[0], x[1]],\n        reverse=True,\n    )\n    used_rows = set()\n    used_cols = set()\n    for row, col in sorted_pairs:\n        # Double check index is in range\n        if row &lt; len(trackers):\n            tracker_obj = trackers[row]\n            # Only assign if the track is \"mature\" or is new but has enough hits\n            if (row not in used_rows) and (col not in used_cols):\n                if (\n                    tracker_obj.number_of_successful_updates\n                    &gt;= minimum_consecutive_frames\n                ):\n                    # If tracker is mature but still has ID -1, assign a new ID\n                    if tracker_obj.tracker_id == -1:\n                        tracker_obj.tracker_id = (\n                            SORTKalmanBoxTracker.get_next_tracker_id()\n                        )\n                    final_tracker_ids[col] = tracker_obj.tracker_id\n                used_rows.add(row)\n                used_cols.add(col)\n\n    # Assign tracker IDs to the returned Detections\n    updated_detections = deepcopy(detections)\n    updated_detections.tracker_id = np.array(final_tracker_ids)\n\n    return updated_detections\n</code></pre>"}]}